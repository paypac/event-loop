## TODOs:
- [ ] better interleaving of source code and instructions in emitted JASM
- [ ] turn Stepper in to a standard Iterator<void> interface
- [ ] get rid of Label.ts
- [ ] refactor global object factory and lib.slow.d.ts (global-object.d.ts?)
- [ ] src/formats/ is not well structured. Some types are really shared between jasm and stepper
- [ ] neaten JASM formatting in emitted JASM
- [ ] get rid of typings.d.ts
- [ ] export proper API, including Epoch and converters
- [ ] www: restore ability to run/step through code. Add a button for this instead of just doing it on every edit.


## Three Formats:

1. **Readable** - a textual representation suitable for authoring by a human developer (also: Writable)
2. **Runnable** - an ephemerial runtime representation suitable for step-wise execution and inspection
3. **Storable** - a serialized representation suitable for persistent storage


## Format Transitions:

1. **Readable to Storable**
  - transpilation from source script to JASM instruction sequence
  - serialization of default register set including ENV = global object

2. **Runnable to Storable**
  - extraction of JASM instruction sequence (one-liner via retained reference to JASM source)
  - serialization of current state (one-liner via JSON3000#stringify)

3. **Storable to Runnable**
  - compilation of JASM instruction sequence into an object akin to a generator object with a step/next method.
  - deserialization of state from JSON3000 format into a state object
  - 


## Shared Functionality/Types:

- JSON3000 (parse & stringify & types)
- global object factory
- global object type declarations


## Public API:
- Epoch stuff (high-level API)
- exposed lower-level functionality





## Moar TODOs
- [ ] restore static checks (ie tsc) in www/ browser version - see kludge in static-check.ts
- [ ] interface Storable { code, data }
- [ ] interface Runnable { step, throwInto, registers }
- [ ] type Readable = string
- [ ] JASM dir (instruction-set, register-set)
- [ ] JSON3000 dir (...)
- [ ] readable-to-storable dir (all from ts-to-jasm)
- [ ] storable-to-runnable dir (???)
- [ ] get rid of `typings.d.ts` files from source code
- [ ] fix current non-robust handling around disallowing/escaping '#' characters in JASM, and label substitution
- [x] ensure '#' character cannot occur in JASM (escape it in literal strings)
- [x] labels: just '#nnn' where nnn is autogenerated
- [x] emit lines with no 'case...' and with labels intact
- [x] in 'build', resolve labels and add switch/case wrapper


## Structure


src/
|
|-- api/
|
|-- transforms/
|   |
|   |-- runnable-to-storable/
|   |   |
|   |   |-- function r_to_s(runnable: Runnable): string;
|   |   |-- <??? goes here...>
|   |
|   |-- storable-to-runnable/
|   |   |
|   |   |-- function s_to_r(storable: string): Runnable;
|   |   |-- <makeGlobal, makeVM, interpreter goes here...>
|   |
|   |-- typescript-to-storable/
|   |   |
|   |   |-- <static checker, compiler front-end, compiler back-end goes here...>

Where?
- interpreter (like a generator object, with next())
- runtime environment (global object, global typings, etc)



```ts
// top-level API
namespace API {
    let default: Epoch;
    class Epoch extends EventEmitter {
        init(options: EpochOptions): void;
        eval(script: string, scriptId?: string): void;
    };
}
interface EpochOptions {

    // TODO: ...
    persistence?: FileStoreOptions; // TODO: Add others to union later...

    // TODO: ...
    createGlobal?: () => {};

    // Custom serializer for saving running script state
    replacer?: (this: any, key: string|number, val: any) => any;

    // Custom deserializer for loading running script state
    reviver?: (this: any, key: string|number, val: any) => any;

    // TODO: add type-checking support later (custom lib.d.ts, etc)...
}


interface FileStoreOptions {
    type: 'fileStore';
    dirname: string;
}


// 'Default' Epoch
import slownode from 'slownode';
slownode.init({
    persistence: {
        type: 'fileStore',
        dirname: './slowfiles'
    }
    createGlobal: () => {
        sleep: ms => new Promise(resolve => setTimeout(resolve, ms)),
        sleepThenFail: (ms, msg) => new Promise((_, reject) => setTimeout(() => reject(new Error(msg)), ms)),
        print: msg => console.log(msg)
    },
    replacer: null, // TODO: ...
    reviver: null   // TODO: ...
});
slownode.on('error', (err, scriptId) => {
    console.log(...);
});
slownode.eval('1+1');



// Isolated Epoch
let epoch = new slownode.Epoch();
epoch.use(...);
epoch.on(...);
epoch.eval(...);





index.ts
jasm
  ...
js-to-jasm
  ...
epoch
  index.ts
  use.ts
  eval.ts
middleware
  options.ts
  builtins
    type-check.ts
    file-store-ts
    auto-await.ts
      





slownode
|
|---src
|   |
|   |---index.ts
|   |
|   |---client
|   |   |
|   |   |---connect.ts
|   |   |
|   |   |---connect-options.ts
|   |
|   |---server
|   |   |
|   |   |---options
|   |   |
|   |   |---jasm
|   |   |
|   |   |---js-to-jasm
|   |   |
|   |   |---plugins
|   |   |   |---tsc           // type: preproc
|   |   |   |---fs            // type: storage
|   |   |   |---pseudo-sync   // type: runtime



```



## Slow Scripting

- [ ] slow.lib.d.ts and the global object are built-in and controlled by the slownode library. Allow options later.
  - [ ] support sleep function / SleepPromise type
  - [ ] Promises as 'opaque' objects
  - [ ] support for DB access (use wrapped 'knex')
  - [ ] support for FD access (use wrapped 'fs')
- [ ] type-checking (via tsc) is automatically on by default for script evaluation. Allow options later.
- [ ] replacer/reviver types are builtin by default. Allow options later.
- [ ] persistence is filesystem-based by default. Directory may be specified as an option. Allow other options later.

- [ ] don't provide/allow primitives/globals/builtins that execute a callback asynchronously
  - e.g. setTimeout, node-style APIs, event emitters, observables, Promise#then, etc
- [ ] treat Promise instances specially
  - the only operation allowed on a promise instance `p` is `await p` (must be checked at runtime at every expression evaluation)
  - corralary of previous: promise instances cannot be assigned, passed as args, have members called, etc... How to enforce?
  - promise values cannot be simply discarded without use (could add a DISCARD #REG opcode to indicate a register is being released from use.)
  - NB: Is this true?: promise instances can only be produced as the return value from a function call, or from new Promise(...).
    - this truth may help narrow down where to check for promises entering the VM
- [ ] what about FRP? Might be convenient to be able to do `source.on('data', data => ...)` in a slow script.
  - but what about missed events? If the process went down/restarted... unreliable...
  - perhaps support sources that are themselves 'slow' in some way... What does this mean?
    - the slow scripts in a epoch could be an interacting ecosystem...
    - some of the scripts are event sources - internally they may poll, externally they emit events
    - some of the scripts are event sinks - they consume the events produced from the slow event sources
    - as long as they are all in the same epoch, and the scripts are 'robust' (define this!), no events will get lost.
    - robust event source - if an erorr occurs, it either recovers and continues, or it takes down the whole epoch... or...?

## New New Scheme

1. tsc --noEmit
  - optional! (just supports extra safety and editor intellisense)
  - catch gross syntax errors and typechecking errors
  - nothing emitted
2. babel transforms
  - catch unsupported syntax (use whitelist)
  - transform async/await/generator functions
  - resolve imports/exports into single AST / single file
3. generate single file output
4. wrap in prolog + epilog 'runner' code --> FINAL JS FILE
  - output file is now runnable
  - exports promise of result/outcome


## New Scheme (Old)

1. tsc --noEmit
  - catch gross syntax errors and typechecking errors
  - nothing emitted
2. esprima --> AST --> whitelist nodes
  - catch unsupported syntax
  - nothing emitted
3. tsc --outFile --amd --es6 --noHelpers
  - emit single output file --> TEMP
4. esprima --> AST --> xform genfuncs --> escodegen
  - transformed output file --> TEMP
5. wrap in prolog + epilog 'runner' code --> FINAL JS FILE
  - output file is now runnable
  - exports promise of result/outcome



## async operations
- [ ] internal
  - [ ] own async function
  - [ ] own generator function (co-like, yields promises, has async runner)
  - [ ] own promise-returning function
  - [ ] own callback-accepting function (no / limited sypport?)
- [ ] external
  - [ ] sleep for specific duration
  - [ ] sleep until specific time
  - [ ] database access
  - [ ] filesystem access
  - [ ] network access

## slow primitives
- [ ] pseudo-globals (module vars)
  - [ ] require
  - [ ] module
  - [ ] exports
- [ ] node globals
  - [ ] TODO: global process control: onUnhandledException, onUnhandledRejection, process.exit, etc
  - [ ] global.Promise (ES6)
  - [ ] global.setTimeout
  - [ ] global.clearTimeout
  - [ ] global.setInterval
  - [ ] global.clearInterval
  - [ ] global.process.nextTick
- [ ] syntax
  - [ ] generator functions (ES6)
  - [ ] async functions (can add these later - use generators for now)

  
## marshalling between slow/ordinary functions
- [ ] slow function calling into ordinary function
- [ ] ordinary function calling into slow function


## What if...
- [ ] we provide our own 'require' implementation:
  - [ ] it parses the module text and interprets it 'slowly'
    - [ ] ordinary functions
    - [ ] generator functions
    - [ ] values
  - [ ] 'require' augmentation is transitive
  - [ ] interop...?


## When do we update our state-of-the-world snapshots?
- [ ] when the stack empties and we return to the event loop?
  - [ ] this fits neatly with DB updates being necessarily asynchronous
- [ ] at every single state change, including synchronous (eg var assignments)
  - [ ] how to update state in DB asynchronously, during a sync operation
  - [ ] *every* operation updates the DB? that's heavy...
- [ ] if the process stops or crashes, we should at least know whether it was sleeping (empty stack) or in the middle of processing an event loop entry (non-empty stack)


## Sample Workflows

```ts
// file: approve-leave-request-workflow.ts
// NB: Call this as soon as a new leave request is created
async function approveLR(lrid: number) {

    // while not approved/rejected
        // if 14+ days passed since application
            // escalate to sysadmin via email...
        // notify/remind approver via email
        // sleep 2 days
    // notify applicant of outcome via email
}
```




```js
function ordinary() {
    var p = new Promise((resolve, reject) => {
        setTimeout(() => resolve(42), 500);
    });
    p = p.then(res => res);
    return p;
}

function* generator() {
    var one = yield Promise.resolve(1);
    var two = yield Promise.resolve(2);
    return one + two;
}

```

