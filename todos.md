## TODOs:
- [ ] what to do/where to put test fixtures?
- [ ] implement stepper-to-jasm
- [ ] refactor global object factory and lib.slow.d.ts (global-object.d.ts?)
- [ ] standard library...
- [ ] instr/opcode casing - use consistently. Make jasm opcodes/directives/registers/labels case-insensitive?
- [ ] Epochs - automatically load & save scripts using fs
- [ ] neaten JASM formatting in emitted JASM
- [ ] export proper API, including Epoch and converters
- [ ] www: get static checks working in browser
- [ ] www: restore ability to run/step through code. Add a button for this instead of just doing it on every edit.
- [ ] *early* error for unawaited promise - preferably static check - use tsc somehow? or some heuristic?
- [x] better interleaving of source code and instructions in emitted JASM
- [x] get rid of typings.d.ts
- [x] ~~get rid of Label.ts~~ actually, leave it in. It's well-localised now.
- [x] get rid of the `async () => {` and `})()` artefacts in source interleaving
- [x] src/formats/ is not well structured. Some types are really shared between jasm and stepper
- [x] source interleaving: 'zip' jasm and ts lines together guided by 'sync points'
- [x] turn Stepper in to a standard Iterator<void> interface



```

Testing a Script object

- load a source string
- iterate over it
- get expected result/error (eventually)
- inspect program/registers??

- suspend/restore in mid-stream using snapshots





```


## Three Formats:

1. **Readable** - a textual representation suitable for authoring by a human developer (also: Writable)
2. **Runnable** - an ephemerial runtime representation suitable for step-wise execution and inspection
3. **Storable** - a serialized representation suitable for persistent storage


## Format Transitions:

1. **Readable to Storable**
  - transpilation from source script to JASM instruction sequence
  - serialization of default register set including ENV = global object

2. **Runnable to Storable**
  - extraction of JASM instruction sequence (one-liner via retained reference to JASM source)
  - serialization of current state (one-liner via KVON#stringify)

3. **Storable to Runnable**
  - compilation of JASM instruction sequence into an object akin to a generator object with a step/next method.
  - deserialization of state from KVON format into a state object
  - 


## Shared Functionality/Types:

- KVON (parse & stringify & types)
- global object factory
- global object type declarations


## Public API:
- Epoch stuff (high-level API)
- exposed lower-level functionality





## Moar TODOs
- [ ] restore static checks (ie tsc) in www/ browser version - see kludge in static-check.ts
- [ ] interface Storable { code, data }
- [ ] interface Runnable { step, throwInto, registers }
- [ ] type Readable = string
- [ ] JASM dir (instruction-set, register-set)
- [ ] KVON dir (...)
- [ ] readable-to-storable dir (all from ts-to-jasm)
- [ ] storable-to-runnable dir (???)
- [ ] get rid of `typings.d.ts` files from source code
- [ ] fix current non-robust handling around disallowing/escaping '#' characters in JASM, and label substitution
- [x] ensure '#' character cannot occur in JASM (escape it in literal strings)
- [x] labels: just '#nnn' where nnn is autogenerated
- [x] emit lines with no 'case...' and with labels intact
- [x] in 'build', resolve labels and add switch/case wrapper


## JASM
- line-based
- 3 line types: instruction, label, blank
- comments start with ';' and run to end of line
- comments are preserved in Program
- canonical instruction lines are aligned with spaces; opcodes start at column 4, args start at column 12
- canonical label lines are not indented


## KVON
- strictness - no silent roundtrip failures - parse(stringify(x)) must result in something that is functionally identical to x, otherwise stringify/parse must throw
- replacers and revivers must occur in dualistic pairs.
- If a `replacer` function returns a replacement value, then the replacement *must* be a discriminated plain object (DPO).
- `reviver` functions will only ever be called with DPO values.
- if a replacer replaces a value, it's pair reviver must revive the replacement value back to the original value.
- if a replacer does not act on a value, it's dual reviver must not act on that value either.
- replacers may not mutate the object containing the value being replaced/revived (passed as `this`).
- revivers always receive `null` for their `this` context (unlike JSON revivers).
- Circular references in object graphs are not supported. But identities *are* preserved for values that recur in DAGs.
- stringify: toJSON is not supported (not reversible)
- stringify `space` parameter: strings containing non-whitespace characters are not supported (not reversible)
- stringify `replacer` parameter: 'whitelist' arrays of property names are not supported (not reversible)
- stringify `replacer` parameter: omitting properties by returning `undefined` from function is not supported
- parse `reviver` parameter: omitting properties by returning `undefined` from function is not supported
- Glossary terms:
  - 'Discriminated Plain Object' (DPO) - plain object with a '$' key
  - 'Discriminant key' - '$'
  - 'Reference' value - string starting with '^'. '^' and '.' are special chars.


## Slow Scripting

- [ ] slow.lib.d.ts and the global object are built-in and controlled by the slownode library. Allow options later.
  - [ ] support sleep function / SleepPromise type
  - [ ] Promises as 'opaque' objects
  - [ ] support for DB access (use wrapped 'knex')
  - [ ] support for FD access (use wrapped 'fs')
- [ ] type-checking (via tsc) is automatically on by default for script evaluation. Allow options later.
- [ ] replacer/reviver types are builtin by default. Allow options later.
- [ ] persistence is filesystem-based by default. Directory may be specified as an option. Allow other options later.

- [ ] don't provide/allow primitives/globals/builtins that execute a callback asynchronously
  - e.g. setTimeout, node-style APIs, event emitters, observables, Promise#then, etc
- [ ] treat Promise instances specially
  - the only operation allowed on a promise instance `p` is `await p` (must be checked at runtime at every expression evaluation)
  - corralary of previous: promise instances cannot be assigned, passed as args, have members called, etc... How to enforce?
  - promise values cannot be simply discarded without use (could add a DISCARD #REG opcode to indicate a register is being released from use.)
  - NB: Is this true?: promise instances can only be produced as the return value from a function call, or from new Promise(...).
    - this truth may help narrow down where to check for promises entering the VM
- [ ] what about FRP? Might be convenient to be able to do `source.on('data', data => ...)` in a slow script.
  - but what about missed events? If the process went down/restarted... unreliable...
  - perhaps support sources that are themselves 'slow' in some way... What does this mean?
    - the slow scripts in a epoch could be an interacting ecosystem...
    - some of the scripts are event sources - internally they may poll, externally they emit events
    - some of the scripts are event sinks - they consume the events produced from the slow event sources
    - as long as they are all in the same epoch, and the scripts are 'robust' (define this!), no events will get lost.
    - robust event source - if an erorr occurs, it either recovers and continues, or it takes down the whole epoch... or...?





# OLD STUFF:
## async operations
- [ ] internal
  - [ ] own async function
  - [ ] own generator function (co-like, yields promises, has async runner)
  - [ ] own promise-returning function
  - [ ] own callback-accepting function (no / limited sypport?)
- [ ] external
  - [ ] sleep for specific duration
  - [ ] sleep until specific time
  - [ ] database access
  - [ ] filesystem access
  - [ ] network access

## slow primitives
- [ ] pseudo-globals (module vars)
  - [ ] require
  - [ ] module
  - [ ] exports
- [ ] node globals
  - [ ] TODO: global process control: onUnhandledException, onUnhandledRejection, process.exit, etc
  - [ ] global.Promise (ES6)
  - [ ] global.setTimeout
  - [ ] global.clearTimeout
  - [ ] global.setInterval
  - [ ] global.clearInterval
  - [ ] global.process.nextTick
- [ ] syntax
  - [ ] generator functions (ES6)
  - [ ] async functions (can add these later - use generators for now)

  
## marshalling between slow/ordinary functions
- [ ] slow function calling into ordinary function
- [ ] ordinary function calling into slow function


## What if...
- [ ] we provide our own 'require' implementation:
  - [ ] it parses the module text and interprets it 'slowly'
    - [ ] ordinary functions
    - [ ] generator functions
    - [ ] values
  - [ ] 'require' augmentation is transitive
  - [ ] interop...?


## When do we update our state-of-the-world snapshots?
- [ ] when the stack empties and we return to the event loop?
  - [ ] this fits neatly with DB updates being necessarily asynchronous
- [ ] at every single state change, including synchronous (eg var assignments)
  - [ ] how to update state in DB asynchronously, during a sync operation
  - [ ] *every* operation updates the DB? that's heavy...
- [ ] if the process stops or crashes, we should at least know whether it was sleeping (empty stack) or in the middle of processing an event loop entry (non-empty stack)


## Sample Workflows

```ts
// file: approve-leave-request-workflow.ts
// NB: Call this as soon as a new leave request is created
async function approveLR(lrid: number) {

    // while not approved/rejected
        // if 14+ days passed since application
            // escalate to sysadmin via email...
        // notify/remind approver via email
        // sleep 2 days
    // notify applicant of outcome via email
}
```
